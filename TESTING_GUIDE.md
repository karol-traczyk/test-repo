# Testing Guide

This repository currently contains only documentation, so there is no automated test suite yet. The guidance below describes the lightweight, Node.js-based workflow we use (or plan to use) for future contributions. Following these steps keeps the setup minimal while still giving fast feedback loops through [Vitest](https://vitest.dev/).

## Overview

- **Primary language**: JavaScript/TypeScript (Node 20 LTS recommended).
- **Test framework**: Vitest for unit/integration coverage, using its Jest-compatible API.
- **Philosophy**: keep tests colocated with the code they exercise, default to small/fast unit tests, and only add heavier integration tests where they add unique value.
- **Tooling**: Node.js, npm scripts, optional VS Code debugging via the built-in Node debugger.

## Install Dependencies

```bash
# Initialize the project if package.json does not exist
npm init -y

# Install testing dependencies
npm install --save-dev vitest @vitest/coverage-v8 typescript ts-node @types/node

# (Optional) Create a Vitest config for advanced settings
npm exec vitest init
```

Add useful npm scripts in `package.json`:

```jsonc
"scripts": {
  "test": "vitest run",
  "test:watch": "vitest",
  "test:coverage": "vitest run --coverage"
}
```

## Run the Full Test Suite

```bash
npm test
```

The command above runs every test in CI-friendly `vitest run` mode. When TypeScript is used, Vitest automatically transpiles the files in-memory via esbuild, so no extra build step is required.

## Run Focused Tests

- **Single file**:

  ```bash
  npx vitest run src/math/add.test.ts
  ```

- **Single test case** (pattern match):

  ```bash
  npx vitest run src/math/add.test.ts -t "adds two numbers"
  ```

- **Watch mode during development**:

  ```bash
  npm run test:watch
  ```

Vitest caches previous runs, so reruns in watch mode stay fast even on large suites.

## Directory & Naming Conventions

- Application code lives under `src/`.
- Tests sit next to the code they validate using the suffix `*.test.ts` or `*.spec.ts`. Example: `src/utils/date-format.ts` and `src/utils/date-format.test.ts`.
- Larger integration tests can go under `tests/` with the same naming scheme.
- Keep helper factories/mocks inside `tests/helpers/` or `src/testing/` so they can be shared.

## Add a New Test (Example)

1. Create production code, e.g. `src/math/add.ts`:

   ```ts
   export const add = (a: number, b: number) => a + b;
   ```

2. Create the colocated test `src/math/add.test.ts`:

   ```ts
   import { describe, expect, it } from "vitest";
   import { add } from "./add";

   describe("add", () => {
     it("adds two numbers", () => {
       expect(add(2, 3)).toBe(5);
     });
   });
   ```

3. Run `npm test -- src/math/add.test.ts` (or rely on watch mode) and commit both files together.

## View & Interpret Results

- Standard output shows per-suite status plus a summary of passed/failed tests and duration.
- For coverage, run:

  ```bash
  npm run test:coverage
  ```

  Coverage artifacts appear under `coverage/` with HTML reports inside `coverage/index.html`.

- Vitest exits with non-zero status on failures, which CI will treat as a failing build.

## Debugging Failing Tests

- Use watch mode plus `--runInBand` to isolate flakiness:

  ```bash
  npx vitest --runInBand src/math/add.test.ts
  ```

- Add targeted logging or `debugger` statements. When running under VS Code, start the “Vitest” debug configuration (auto-generated by `vitest init`), set breakpoints, and hit F5.
- Re-run a single failing test with `-t "<test name>"` to avoid unrelated noise.
- For async tests, ensure promises are awaited; Vitest will warn about open handles—re-run with `--logHeapUsage` if you suspect leaks.

## Continuous Integration

No CI configuration exists yet. A minimal GitHub Actions workflow would look like:

```yaml
name: CI
on:
  push:
  pull_request:
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm
      - run: npm ci
      - run: npm test
```

CI should run the same `npm test` command used locally to avoid drift. Add `npm run test:coverage` if you want coverage gating.

## Additional Tips

- Commit the `vitest.config.ts` and `tsconfig.json` files so contributors share the same settings.
- Prefer deterministic data builders over network calls. If integration tests need HTTP, use MSW (Mock Service Worker) or supertest to stay hermetic.
- Keep flaky tests quarantined by tagging them with `it.skip` (and linking to an issue) until they can be stabilized.
